读写集语义
~~~~~~~~~~~~~~~~~~~~~~~~

本文档讨论有关读写集语义实现的详细信息

事务模拟和读写集
'''''''''''''''''''''''''''''''''''''''''

在``endorser``上进行交易模拟时，会为交易准备一个读写集。``读集``包含一个键列表和在模拟过程中所要读取的键版本号（而不是值）。``写集``含有键列表（尽管可能被读集中的键覆盖），和事务所写入的新值。如果事务执行的更新内容是删除键，则为键设置一个删除标记（代替新值）。

此外，如果事务向一个键多次写入同一个值，则仅保留最后写入的值。同样，如果事务读取键的值，则即使事务在发出读取之前已更新键的值，也将返回处于提交状态的值。换句话说，不支持“读即写”语义。

如前所述，键的版本仅记录在读集中。写集仅包含唯一键的列表及其由事务设置的最新值。

实现版本的方案可能有多种。版本控制方案的最低要求是为给定的键生成非重复的标识符。例如，可以对版本使用单调递增的数字来标记。在当前实现中，我们使用基于区块高度的版本控制方案，其中将提交事务的高度用作该事务修改的所有键的最新版本。在此方案中，事务的高度由数组表示（ txNumber 是区块事务的高度）。与增量编号方案相比，此方案具有许多优点-首当其冲的是，它使其他组件（如 saidb，事务模拟和验证）能够做出有效的设计选择。

以下是模拟交易仿真的读写集示例的说明。为了简单起见，在图示中，我们使用增量数字表示版本。

::

    <TxReadWriteSet>
      <NsReadWriteSet name="chaincode1">
        <read-set>
          <read key="K1", version="1">
          <read key="K2", version="1">
        </read-set>
        <write-set>
          <write key="K1", value="V1"
          <write key="K3", value="V2"
          <write key="K4", isDelete="true"
        </write-set>
      </NsReadWriteSet>
    <TxReadWriteSet>

此外，如果事务在模拟过程中执行范围查询，则范围查询及其结果将作为 ``query-info`` 添加到读写集中

使用读写集进行事务验证和世界状态更新
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

 ``committer`` 使用读写集的读集部分检查事务的有效性，并使用读写集的写集部分更新相关键的版本和值。

在验证阶段，如果事务的读集中的每个键的版本与世界状态下的对应键的版本相匹配，则该事务是 ``有效的`` -假设所有前序的有效事务（包括同一区块中的前序事务）都已提交（*committed-state*）。如果读写集还包含一个或多个查询信息，则将执行附加验证。

这个额外验证应确保，在查询结果的超范围（即范围的并集）中没有插入/删除/更新键。换言之，如果我们在进行状态验证时，重新执行任何范围查询（在模拟过程中执行事务），则该范围查询产生的结果，应与模拟时事务观察到的结果相同。如此一来可确保，如果事务在提交期间观察到幻影项（phantom
items），则应将该事务标记为无效。请注意，这种保护仅限于范围查询（即 ``GetStateByRange`` 链码中的函数），尚未针对其他查询实现（即， ``GetQueryResult`` 链代码中的功能）。其他查询可能会产生幻影，因此，除非应用程序可以保证结果集在仿真与验证/提交时间之间的稳定性，否则其他对未提交到 ordering 服务的事务应提供只读查询。

如果事务通过了有效性检查，则提交者将使用写集更新世界状态。在更新阶段，对于写集中存在的每个键，将该键在世界状态下的值，设置为写集中指定的值。此外，世界状态下的键的版本也被改为最新版本。

示例模拟与验证
'''''''''''''''''''''''''''''''''

本节通过一个场景帮助理解语义。为了进行示例，在世界状态下，键由数组 ``(k,ver,val)`` 进行表示， 其中 ``ver`` 表示键的最新版本， ``val`` 表示``k``的值。

现在，考虑``T1, T2, T3, T4, T5``五个交易，所有交易都在世界状态的同一快照上模拟。以下代码段显示了模拟交易所依据的世界状态的快照，以及每个交易所执行的读取和写入活动的顺序。

::

    World state: (k1,1,v1), (k2,1,v2), (k3,1,v3), (k4,1,v4), (k5,1,v5)
    T1 -> Write(k1, v1'), Write(k2, v2')
    T2 -> Read(k1), Write(k3, v3')
    T3 -> Write(k2, v2'')
    T4 -> Write(k2, v2'''), read(k2)
    T5 -> Write(k6, v6'), read(k5)

现在，假定这些事务按T1，..，T5的顺序排序（可以包含在单个区块中或不同区块中）

1. ``T1`` 通过验证，因为他不需要任何读取。然后， ``k1`` 和 ``k2`` 两个键在世界状态中的数组被更新为``(k1,2,v1'), (k2,2,v2')``

2. ``T2`` 验证失败，因为它读取了一个 ``k1`` ，该键已经被之前的事务 ``T1`` 修改过。

3. ``T3`` 通过验证，因为它不执行读取。然后，``k2`` 键在世界状态中的数组被更新为 ``(k2,3,v2'')`` 

4. ``T4`` 验证失败，因为它读取了一个 ``k2`` ，该键已经被之前的事务 ``T1`` 修改过。

5. ``T5`` 通过验证，因为它读取了一个 ``k5`` ，该键没有被任何前序事务修改过。

**注意**: 目前不支持具有多个读写集的事务。

.. Licensed under Creative Commons Attribution 4.0 International License
   https://creativecommons.org/licenses/by/4.0/
